/**
 * Test code for the DisjointSet data-structure.
 * See sample_output.txt for results of executing these tests.
 *
 * @author M. Allen
 */

public class Main
{  
    /**
     * Tests the data-structure and its methods.
     *
     * @param args Not used.
     */
    public static void main( String[] args )
    {
        // We create our structure and add two elements.
        System.out.println( "Adding two data elements (A and B)" );
        DisjointSet<String> ints = new DisjointSet<>();
        ints.add( "A" );
        ints.add( "B" );
        ints.add( "A" );
        ints.add( "B" );
        
        // Test the basic size(), numSets(), contains() methods.
        // This creates two separate sets, each with a single element.
        System.out.println( "Size: " + ints.size() );
        System.out.println( "Number of sets: " + ints.numSets() );
        System.out.println( "contains( A ): " + ints.contains( "A" ) );
        System.out.println( "contains( B ): " + ints.contains( "B" ) );
        System.out.println( "contains( C ): " + ints.contains( "C" ) );
        
        // Test the getSet() method, which should return the input value itself,
        // since each object is currently in a separate set.
        System.out.println( "\ngetSet( A ): " + ints.getSet( "A" ) );
        System.out.println( "getSet( B ): " + ints.getSet( "B" ) );
        
        // The following line, when un-commented, should cause a
        // NoSuchElementException, explaining that "C" does not exist.
        // System.out.println( "getSet( C ): " + ints.getSet( "C" ) );
        
        // Test the inSameSet() method. For different objects, this will be
        // false at the moment; on any object and itself, true.
        System.out.println( "\ninSameSet( A, B ): " + ints.inSameSet( "A", "B" ) );
        System.out.println( "inSameSet( B, A ): " + ints.inSameSet( "B", "A" ) );
        System.out.println( "inSameSet( A, A ): " + ints.inSameSet( "A", "A" ) );
        System.out.println( "inSameSet( B, B ): " + ints.inSameSet( "B", "B" ) );
        
        // The following lines, when un-commented, will generate exceptions. The
        // first two will explain that "C" does not exist. The last should
        // explain that NEITHER "C" NOR "D" exist.
        // System.out.println( "inSameSet( A, C ): " + ints.inSameSet(
        // "A", "C" ) );
        // System.out.println( "inSameSet( C, A ): " + ints.inSameSet(
        // "C", "A" ) );
        // System.out.println( "inSameSet( C, D ): " + ints.inSameSet(
        // "C", "D" ) );
        
        // Test the sizeOfSet() method. Each set currently has only a single
        // element.
        System.out.println( "\nsizeOfSet( A ): " + ints.sizeOfSet( "A" ) );
        System.out.println( "sizeOfSet( B ): " + ints.sizeOfSet( "B" ) );
        
        // Another exception should be generated by the following.
        // System.out.println( "sizeOfSet( C ): " + ints.sizeOfSet( "C" ) );
        
        // We now add some more elements to the set, and check the size values.
        System.out.println( "\nAdding 3 more data elements (C, D, E)" );
        ints.add( "C" );
        ints.add( "D" );
        ints.add( "E" );
        System.out.println( "Size: " + ints.size() );
        System.out.println( "Number of sets: " + ints.numSets() );
        
        // We now form the union of the two sets containing "A" and "B".
        System.out.println( "\nForming union of A and B" );
        String rootData = ints.union( "A", "B" );
        
        // Since the original sets each had same rank (0), the resulting root is
        // randomly chosen, and may be "A" OR "B". Whatever is chosen will also
        // be reported when we run getSet(). Overall number of sets will
        // decrease by 1, and size of set containing "A" will increase by 1.
        System.out.println( "A and B now share root: " + rootData );
        System.out.println( "Number of sets: " + ints.numSets() );
        System.out.println( "getSet( A ): " + ints.getSet( "A" ) );
        System.out.println( "getSet( B ): " + ints.getSet( "B" ) );
        System.out.println( "inSameSet( A, B ): " + ints.inSameSet( "A", "B" ) );
        System.out.println( "sizeOfSet( A ): " + ints.sizeOfSet( "A" ) );
        
        // We now form the union of sets containing "A" and "C". Since "A" and
        // "B" are ALREADY in a set together, this will put all 3 in the same
        // set, with whatever root that set ended up with in the prior step.
        // (While random, here this MUST be either "A" or "B", NOT "C", since
        // "C" has a lower rank (0) than that of the other set (1).
        System.out.println( "\nForming union of A and C" );
        rootData = ints.union( "A", "C" );
        System.out.println( "A and C now share root: " + rootData );
        System.out.println( "Number of sets: " + ints.numSets() );
        System.out.println( "getSet( A ): " + ints.getSet( "A" ) );
        System.out.println( "getSet( B ): " + ints.getSet( "B" ) );
        System.out.println( "getSet( C ): " + ints.getSet( "C" ) );
        System.out.println( "inSameSet( A, B ): " + ints.inSameSet( "A", "B" ) );
        System.out.println( "inSameSet( A, C ): " + ints.inSameSet( "A", "C" ) );
        System.out.println( "inSameSet( B, C ): " + ints.inSameSet( "B", "C" ) );
        System.out.println( "sizeOfSet( A ): " + ints.sizeOfSet( "A" ) );
        
        // Now we union "D" and "E", then "C" and "E". Since "C" is already in a
        // set with "A" and "B", this will union ALL elements together into a
        // single set. Due to randomness and rank, the final root can be
        // ANYTHING EXCEPT "C", and will differ on different runs.
        System.out.println( "\nForming union of D, E, and C" );
        ints.union( "D", "E" );
        rootData = ints.union( "C", "E" );
        System.out.println( "C and E now share root: " + rootData );
        System.out.println( "Number of sets: " + ints.numSets() );
        System.out.println( "getSet( D ): " + ints.getSet( "D" ) );
        System.out.println( "getSet( E ): " + ints.getSet( "E" ) );
        System.out.println( "inSameSet( A, B ): " + ints.inSameSet( "A", "D" ) );
        System.out.println( "inSameSet( A, E ): " + ints.inSameSet( "A", "E" ) );
        System.out.println( "sizeOfSet( A ): " + ints.sizeOfSet( "A" ) );
        
        // The following will do nothing, since everything is already in a
        // single set. The resulting values for the root, size, and number of
        // sets will be identical to the previous test.
        System.out.println( "\nForming union of B and D" );
        rootData = ints.union( "B", "D" );
        System.out.println( "B and D now share root: " + rootData );
        System.out.println( "Number of sets: " + ints.numSets() );
        System.out.println( "sizeOfSet( B ): " + ints.sizeOfSet( "B" ) );
    } 
}
